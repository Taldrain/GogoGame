\input{preambule.tex}

\tableofcontents

\chapter*{Introduction}

This report is about the GO contest of the AI course.\\
It contains detailed description of the AI project.\\
\\
At the beginning the project was designed in C++ but then we decide to change to
a completly different langage OCaml.\\
With this powerfull langage we managed to write some great algorithm like an UCT
or a Neural Network.\\


\chapter{Common Part}

In this part, we will discuss about the common work of the group.

Firstly, we will discuss our choice to use OCaml, a functionnal language.
Then, we will see the differents algorithms we choose to implement and, last but not least.

\section{The choice of a functionnal Language}

\subsection{Explanations}

The classics way for programming this project was C or C++. It's the general choice, the choice that a lot of groups make.

Otherwise, these languages are lacking a lot on sides that matters from an strictly algorithmic point of view.

The most important problem with C-based languages is that they are state-based. A variable is a location on the memory and the programmer have to manage this memory himself, changing value by hand.\\

In this way, programming have a lot of side-effects, and the whole program is weakened by  an approximative memory gestion.

Good programmers use the manual memory gestion as an advantage in order to gain efficiencity, but our project is not about memory gestion but Articifial Intelligence algorithms.\\

On the other way, functionnal programming avoid mutable variables and changing states but use functionnal application of contants values.

This permit a way of programming with very few side-effects, with less memory management, and permit to be more focused on the algorithm itself.

\subsection{Why OCaml}

There is differents functionnal programming langagues : \textsc{Lisp}, Haskell, OCaml, Erlang\ldots

We choose OCaml because:
\begin{itemize}
\item It is really fast
\item It is Object Oriented ready
\item It have many mature tools helping for project management
\item And, mainly, because we were all already familar with OCaml
\end{itemize}


\section{Algortihms}

In this sectionm we will discuss about the differents algorithms we decided to implements, and describe how we implements it.

\subsection{Upper bound for Confidence Tree (\textsc{UCT})}

The Upper bound for Confidence Tree algorithm, also named UCT, is a derivative of the Monte-Carlo methods.\\

The Monte-Carlo method deals with statistics. The main idea is to play randomly a lot and a lot of games, counting the winning and the losing games with a play.

Statically, the play with the highest winning rate is not a bad play. More the engine play random games and more accurate the statistic is. With enough computer power, and enough sinulations, the resulting plays are all good.\\

But the Monte-Carlo itself is to wide for a Go board. The is to many moves to be really effective.

This is why the team behinf Mogo improve it with the UCT algorithm, wich combine Monte-Carlo with some selection in order to gain efficiency.\\

We implemeted UCT basicly, with nodes containing mutables data --- like the visits of the winning rate --- representing the state of the board.

The goal was to have a common state representation fo the board, shared between all the differents algorithms we use, even if they use it in a different manner.

In this way, we can share the state generation between algorithms and sharing the optimization we found.\\

Unfortunately, we didn't found the time to optimize the state generation. A smart state generation will favorize good moves, putting the worsts in the bottom of an ordered structure, and will organize all in a smart and effective data strcuture like a heap or a stream.\\

As the state generation is not a rigid need for UCT work, we didn't prioritize this work . It was a bad decision : all our algorithms would have a real gain of a good state generation. Both in term of speed or accuracy.


\subsection{Negascout}

One of the most commonly used algorithm for two players game with total knowledge is the Min-Max based algorithms.

Negascout is one of them. It profits of the efficiency given by $\alpha-\beta$ prunnig in alliance with the strength of the SCOUT algorithm.

\paragraph{The $\alpha-\beta$ Algorithm}
is an ammelioration of Min-Max algorithms. It use prunning to avoid expanding all the children states of a given state.

If the evaluation function give a value that is under the lower bound or find a better value that the upper bound, it stops the expansion and give back the best find value.

\paragraph{The SCOUT Algorithm} was more a theorical purpose algorithm. It use the ordering of the children to bet that the firsts are more effective thant the other.

It evaluate the firsts son of the current node, and test if the value of the first child is the best. If it is not, it reevaluate the set of the children in order to improve the ordering.

This strategy give better results than $\alpha-\beta$ for deep trees.\\

All Min-Max based algorithm use an evaluation function, also called heuristic function.
Our evaluation function used differents parts of the board:
\begin{description}
\item[The position], as playing in the corner or in the border is generally a bad move, we can give a malus to these cells. In the same way, playing in the middle is somewhat weak if no groups or shape are in support. A little malus was given for the middle too.

In the other side, the second and the third line are really good location to build a strength territory without fearing the adversary. We can give a bonus to these cells.

\item[Shapes] are stones that could be easily connected but are not. It's the mark of a good player to know and build shapes in his territory.

Our AI have a small library of shapes (about 30) that are tested to see if some of the stones matche or not. This is obviously a great bonus.

\item[Groups] are the essence of the Go game. If you want to win, you have to make  strong groups with a lot of liberty, or eyes.\\
The evaluation function have a group module. It count the number of groups and its liberty. With the positionning function and the shape function, we can give a rating point to a group, mesuring its importance in the game.
\end{description}

Our evaluation function is quiet simple relatively to the major go AI, and lacks of a lot of optimizations.

\subsection{Genetic Algorithm and Neural Network}

Neural networks are fast and efficient with a learning base big enough.

Because we knowed that a lot of game of Go (already played) are easily
accessible we wanted to have an easy way to know if it's better to attack or
defend at a t time. This is possible by a genetic algorithm and a neural
network.\\
\\
We create a neural network, no intern layout it's not necessary for what we
want, that have in input the number of vertice in a Go board and in output we
have the response, we know if we have to attack or defend.\\
Of course it's necessay to do some learning because otherwise we would have to
test each combination of weight for each node. Speaking of which, the function
used to determine the output is the Sigmoid function.\\
\\
So, the other part is the genetic algorithm. It's independant with the
neural network but necessary. In our project we used it to shuffle, mutate and
do some cross-over with our data of weight.\\
After that we have a completly new population, supposed better, that we take to
replace our current data of weight in our neural network.\\
\\
These two algorithms have been implemented in a completly generic way so that we
can use them for whatever we want.\\

\section{Results}

\chapter{Individual Part}

\section{Tasks}

\section{Personnal value in the project}

\section{Individual Conclusion}

\chapter*{Conclusion}
plap

\end{document}
